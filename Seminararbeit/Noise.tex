\chapter{Noise}
Synthetisch erzeugtes Rauschen \emph{(engl. Noise)} erweist sich als hilfreiches Mittel zur Erzeugung von zufällig erscheinenden Strukturen.
Als wohl bekannteste Implementierung ist hier die Implementierung von Ken Perlin\cite{PERLIN1985} zur Erzeugung einer Marmortextur auf einer Vase zu nennen\footnote{Auch als \emph{Perlin-Noise} bezeichnete Implementierung von Gradient Noise in 3-D}.

Neben umfangreichen Anpassungsmöglichkeiten durch verschiedene Parameter ist die Performance dieses Verfahrens ein entscheidender Grund für die Nutzung. Noise verbraucht extrem wenig Speicher, ist relativ einfach zu berechnen und ist zu jeder Zeit an einer beliebigen Stelle auswertbar, was es auch für Echtzeitanwendungen geeignet macht.\cite{H.Hauser2010}

Dieses Kapitel soll ein grundlegendes Verständnis über Noise-Funktionen bieten. Dazu werden zuerst grundlegende Komponenten, welche jeder Implementierung zugrunde liegen, erläutert. Anschließend werden \emph{Value-}\ref{Value-Noise}, \emph{Gradient-Noise}\ref{Gradient-Noise} sowie \emph{Fractal-Noise}\ref{Fractal-Noise} erklärt, bevor es einen Ausblick auf den \emph{Simplex-Noise}\ref{Simplex-Noise} Algorithmus gibt. 

\section{Grundlagen}
\subsection{Auxilary-Function}\label{auxFunc}
Der erste Schritt zur Erzeugung von Noise ist in der Regel eine sog. \emph{Auxilary-Function}\cite{fractalsAndChaos} der Form \begin{math}\mathbb aux: {Z}^n \mapsto [-1 - 1]\end{math}\label{auxFunc}.
Diese dient zur Beschreibung eines Gitters, welches die Form unserer zukünftigen Noise-Funktion bestimmen wird. Die Funktion muss dabei unbedingt deterministisch sein\footnote{Siehe\ref{Fractal-Noise}, sie muss also für jede Koordinate eines Gitterpunktes immer denselben Funktionswert liefern.}.

Die Wahl der Auxilary Funktion ist entscheident für das spätere Erscheinungsbild der Noise-Funktion.
Eine gleichverteilte Folge von pseudo zufällige Zahlen wie sie etwa die meisten in Programmiersprachen implementierten Zufallsgeneratoren bieten erfüllt zwar die Anforderungen der Deterministik der Funktion, kann allerdings zu unerwünscht starken Differenzen zwischen zwei Benachbarten Gitterpunkten führen. Im folgenden gehen wir von einer Standartnormalverteilung aus um die Wahrscheinlichkeit für Werte nahe den Intervalgrenzen zu verringern. 

\subsection{Interpolation und Fade-Function}
Um aufbauend auf der Auxilary-Function\ref{auxFunc} eine Funktion $S(\vec{x}): \mathbb{R}^n\mapsto\mathbb{R}, \vec{x}\in \mathbb{Z}^n$\label{S} zu definieren wird zwischen benachbarten Gitterpunkten lokal interpoliert. Dafür wird eine sogenannte Fade-Function\cite{fadeFunction} der Form $f(t): \mathbb{R}\mapsto\mathbb{R}$ mit $t\in[0, 1]$ definiert, welche den Übergang zwischen den Gitterpunkten steuert.

Um überhaupt eine stetige Noise-Funktion zu ermöglichen, muss 
\begin{equation}
f(0) = 0 \land f(1) = 1
\end{equation} gelten.
Damit der Übergang zwischen den Gitterpunkten möglichst glatt und damit natürlich wirkt, sollte jedoch eine Stetigkeit von $C^2$ und damit die Eigenschaften 
\begin{equation}
	f'(0) = f'(1) = 0 = f''(0) = f''(1)
\end{equation} 
gelten.

Dafür wird im folgenden das Polynom $f(t) = 6t^5-15t^4+10t^3$ benutzt, welches auch in Perlins Referenzimplementierung Verwendung findet\cite{BurgerGradientNoise2008} und alle Eigenschaften erfüllt.

Da die mit $f(t)$ gebildete, interpolierte Funktion $S(\vec{x})$ definiert nun die Noise-Funktion.


\section{Value-Noise}\label{Value-Noise}

\section{Gradient-Noise}\label{Gradient-Noise}

\section{Fractal-Noise}\label{Fractal-Noise}

\section{Ausblick: Simplex-Noise}\label{Simplex-Noise}






