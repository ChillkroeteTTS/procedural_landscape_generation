\chapter{Noise}
\section{Grundlagen}
Noise bietet einige Eigenschaften, welche sich sehr gut zur Erzeugung prozedural erzeugtem Content eignen.
Von einer einfach erzeugten Folge von Zufallszahlen grenzt sich eine Noise Funktion dadurch ab, dass sie eine Kontinuität aufweist.
%Während bei Zufallszahlen die Differenz zwischen zwei nebeneinanderliegenden Punkten sehr groß
Durch die, je nach Funktion verschiedenen, Parametern lassen sie sich sehr gut an das gewünschte Ergebnis anpassen. Neben dem geringen Speicherverbrauch einer Implementierung ist besonders die Auswertbarkeit an einer beliebigen Position der Funktion für jede Echtzeitanwendung von entscheidender Bedeutung.

Ziel ist also eine Funktion der Form:

\begin{math}
	noise(x): \mathbb{R}^d \mapsto \mathbb{R}, d \in \mathbb{N}
\end{math}

Für die Erklärung in diesem Grundlagenkapitel gehen wir davon aus, dass wir eine eindimensionale Value-Noise Funktion erzeugen wollen.


\subsection{Auxilary-Function}\label{auxFunc}
Der erste Schritt zur Erzeugung von Noise ist in der Regel eine sog. \emph{Auxilary-Function}\cite{fractalsAndChaos} \begin{math}\mathbb S(k): {Z}^n \mapsto \mathbb{R}\end{math} wobei $n\in\mathbb{N}$ ein Skalarfeld mit Dimension $n$ beschreibt.
Um mit der Funktion gut weiterarbeiten zu können sollten die Funktionswerte in zwischen -1 und 1 liegen.

Die Wahl der Auxilary-Function ist die erste Entscheidung, welches das Erscheinungsbild der Noise-Funktion entscheident beeinflusst.
Hier muss für den jeweiligen Anwendungsfall unterschieden werden. Eine gleichverteilte Zufallsfunktion etwas hätte für eine Landschaft zur Folge, dass die Wahrscheinlichkeit für sehr hohe/tiefe Stellen unnatürlich hoch wäre. Hier bietet sich die Standartnormalverteilung an.

\subsection{Interpolation und Fade-Function}
Um aufbauend auf der Auxilary-Function $S(k)$ eine Funktion $S_1(x): \mathbb{R}\mapsto\mathbb{R}$ zu definieren wird zwischen zwei nebeneinanderliegenden Werten $g=S(floor(x))$ und $h=S(ceil(x))$ interpoliert. Die Interpolation wird mit einer sog. Fade-Function\cite{fadeFunction} der Form $f(t, g, h)$ mit $t\in[0, 1]$ durchgeführt. Eine Funktion muss mindestens die Kriterien

$f(t_0)=0 \land f(t_1)=1$ 
erfüllen, wünschenswert sind jedoch ebenfalls die Eigenschaften
$f'(t_0)=0 \land f'(t_1)=0 \land f''(t_0)=0 \land f''(t_1)=0$ um einen möglichst stetigen Übergang zu schaffen.
Der Erfinder des Perlin-Noise Algorithmus benutzt hierfür das Polynom $6x^5-15x^4+10x^3$\cite{BurgerGradientNoise2008}, welches alle genannten Eigenschaften hat und hier auch weiter genutzt werden soll.

Aus den obigen Überlegungen resultiert nun eine Funktion:

\begin{equation}\label{s1}
	S_1(x) = f(x-\lfloor{x}\rfloor, \lfloor{x}\rfloor, \lceil{x}\rceil).
\end{equation}

wobei man es sich anbietet diese über $x_f = x / n$ zu definieren wobei 

n = Anzahl der Punkte in dem Skalarfeld aus \ref{auxFunc} ist. 
Damit ergibt sich:

\begin{equation}\label{eq:s1f}
	S_{1f}(x_f) = S_1(x_f * n).
\end{equation}

\subsection{Erzeugung von fractal Noise}
Ein großer Vorteil von Noise Funktionen ist, dass ihre Auflösung praktisch unbegrenzt ist. 
Dies erreicht man indem die Noise-Funktion mit einer skalierten Version von sich selbst überlagert wird. Das Resultat wird auch \emph{fractal noise} genannt.
Der Grad der Skalierung kann dabei frei gewählt werden, jedoch bietet sich eine Halbierung der Amplitude sowie eine Stauchung der ganzen Funktion um 2 an.
Für \ref{eq:s1f} ergibt sich dabei dann folgender \emph{Value-Noise}:
\begin{equation}\label{1dvaluenoise}
	1dValueNoise(x)=\sum_{1}^{r} \frac{S_{1f}(x^r)}{2^r}
\end{equation}
wobei $r \in \mathbb{N}$ den Rekursionsfaktor angibt.






